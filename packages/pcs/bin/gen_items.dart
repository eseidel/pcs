/// Generate items.dart from items.csv

import 'dart:io';

import 'package:pcs/item.dart';

extension TakeExtension<E> on Iterator<E> {
  E? takeOne() {
    if (moveNext()) {
      return current;
    }
    return null;
  }
}

class Entry {
  Map<String, String> fields = {};
  Entry(this.fields);

  // This class exists to cause generation code to fail if/when the
  // header names change.
  String operator [](String key) => fields[key]!;
}

List<Entry> _readCSV(String path) {
  var file = File(path);
  var lines = file.readAsLinesSync();
  var linesIter = lines.iterator;
  var header = linesIter.takeOne()!.split(',');
  var result = <Entry>[];
  while (linesIter.moveNext()) {
    var fields = <String, String>{};
    int index = 0;
    for (var value in linesIter.current.split(',')) {
      fields[header[index]] = value;
      index++;
    }
    result.add(Entry(fields));
  }
  return result;
}

class IntentingBuffer {
  StringBuffer buffer;
  int indentLevel;

  IntentingBuffer()
      : buffer = StringBuffer(),
        indentLevel = 0;

  void indent() {
    indentLevel++;
  }

  void unindent() {
    indentLevel--;
  }

  void writeln([String text = '']) {
    if (text.isEmpty) {
      buffer.writeln();
    } else {
      buffer.writeln('${'  ' * indentLevel}$text');
    }
  }

  @override
  String toString() => buffer.toString();
}

void main() {
  var items = _readCSV('items.csv');
  items.sort((a, b) => a['key'].compareTo(b['key']));
  var file = File('lib/gen/items.dart');
  var buffer = IntentingBuffer();

// key,name,type,power,oxygen,biomass,heat,pressure,dependency_1,dependency_2,dependency_3,dependency_4,dependency_5,dependency_6,dependency_7,dependency_8,dependency_9

  buffer.writeln("// Generated by bin/gen_items.dart");
  buffer.writeln("// Do not edit this file directly.");
  buffer.writeln();
  buffer.writeln("import 'package:pcs/structures.dart';");
  buffer.writeln();
  buffer.writeln('class Items {');
  buffer.indent();

  for (var item in items) {
    buffer.writeln('static const ${item['key']} = Item(');
    buffer.writeln('  key: \'${item['key']}\',');
    buffer.writeln('  name: \'${item['name']}\',');
    buffer.writeln('  type: ItemType.${item['type']},');
    var energy = item['power'].isEmpty ? '0.0' : item['power'];
    buffer.writeln('  energy: $energy,');
    if (['oxygen', 'biomass', 'heat', 'pressure']
        .any((key) => item[key].isNotEmpty)) {
      buffer.writeln('  progress: Progress(');
      if (item['oxygen'].isNotEmpty) {
        buffer.writeln('    oxygen: O2.ppq(${item['oxygen']}),');
      }
      if (item['biomass'].isNotEmpty) {
        buffer.writeln('    biomass: Biomass.g(${item['biomass']}),');
      }
      if (item['heat'].isNotEmpty) {
        buffer.writeln('    heat: Heat.pK(${item['heat']}),');
      }
      if (item['pressure'].isNotEmpty) {
        buffer.writeln('    pressure: Pressure.nPa(${item['pressure']}),');
      }
      buffer.writeln('  ),');
    }

    buffer.writeln('  cost: [');
    for (int i = 1; i <= 9; i++) {
      var dependency = item['dependency_$i'];
      if (dependency.isNotEmpty) {
        buffer.writeln('    Items.$dependency,');
      }
    }
    buffer.writeln('  ],');

    // FIXME: This data is missing from the csv.
    buffer.writeln('  unlocksAt: Goal.zero(),');
    buffer.writeln('  location: Location.outside,');

    buffer.writeln(');');
    buffer.writeln();
  }
  buffer.unindent();

  buffer.writeln();
  buffer.writeln('  static const all = [');
  for (var item in items) {
    buffer.writeln('    ${item['key']},');
  }
  buffer.writeln('  ];');

  buffer.writeln();
  buffer.writeln('  static const structures = [');
  for (var item in items) {
    var type = ItemType.fromName(item['type']);
    if (type.isStructure) {
      buffer.writeln('    ${item['key']},');
    }
  }
  buffer.writeln('  ];');

  buffer.writeln('}'); // close Items class.

  file.writeAsStringSync(buffer.toString());
}
